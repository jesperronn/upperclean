#!/bin/bash

###############################################################################
# upperclean - Developer cleanup utility with multi-level cleanup
# Removes caches, temporary files, and build artifacts
###############################################################################

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
DRY_RUN=false
FORCE=false
GLOBAL=false
INTERACTIVE=true              # Interactive (multi-select) is default
SKIP_INTERACTIVE=false        # Set true with --no-interactive to disable prompts
CLEANUP_LEVEL="standard"
TOTAL_RECOVERY=0
OS_TYPE=""
declare -a CATEGORY_FILTER  # Empty = all categories, or specific ones like (docker npm maven)

# Detect OS
detect_os() {
  case "$(uname -s)" in
    Darwin*) OS_TYPE="macos" ;;
    Linux*) OS_TYPE="linux" ;;
    CYGWIN* | MINGW*) OS_TYPE="windows" ;;
    *) OS_TYPE="unknown" ;;
  esac
}

###############################################################################
# CLEANUP TARGETS - Organized by level
# Global targets for system-wide cleanup
###############################################################################

# QUICK level targets (safe, low-complexity, zero risk)
declare -a QUICK_TARGETS
setup_quick_targets() {
  QUICK_TARGETS=(
    "npm cache|npm cache clean --force|npm"
    "pip cache|pip cache purge|pip"
    "yarn cache|yarn cache clean|yarn"
    "ruby gems|gem cleanup|ruby"
    "docker dangling images|docker image prune -f|docker"
  )
}

# STANDARD level (add to Quick) - safe system cleanup
declare -a STANDARD_TARGETS
setup_standard_targets() {
  STANDARD_TARGETS=(
    "docker containers|docker container prune -f|docker"
    "docker build cache|docker builder prune -f|docker"
    "brew caches|brew cleanup --prune=all|homebrew"
  )

  if [[ "$OS_TYPE" == "linux" ]]; then
    STANDARD_TARGETS+=(
      "apt caches|sudo apt clean && sudo apt autoclean|apt"
    )
  fi
}

# DEEP level targets (add to Standard) - HIGH RISK, needs multi-select
declare -a DEEP_TARGETS
setup_deep_targets() {
  DEEP_TARGETS=(
    "gradle caches|rm -rf ~/.gradle/caches|gradle"
    "cargo cache|cargo cache --autoclean|cargo"
    "sbt cache|rm -rf ~/.sbt|sbt"
  )

  if [[ "$OS_TYPE" == "macos" ]]; then
    DEEP_TARGETS+=(
      "Xcode derived data|rm -rf ~/Library/Developer/Xcode/DerivedData/*|xcode"
      "JetBrains caches|rm -rf ~/Library/Caches/JetBrains/*|jetbrains"
      "crash dumps|rm -rf ~/Library/Logs/DiagnosticMessages/*|system"
    )
  elif [[ "$OS_TYPE" == "linux" ]]; then
    DEEP_TARGETS+=(
      "JetBrains caches|rm -rf ~/.cache/JetBrains/*|jetbrains"
      "VS Code cache|rm -rf ~/.cache/Code/*|vscode"
    )
  fi
}

# AGGRESSIVE level targets - VERY HIGH RISK, mandatory multi-select
declare -a AGGRESSIVE_TARGETS
setup_aggressive_targets() {
  AGGRESSIVE_TARGETS=(
    "docker system prune -a|docker system prune -a -f|docker"
    "maven repository|rm -rf ~/.m2/repository|maven"
  )

  if [[ "$OS_TYPE" == "macos" ]]; then
    AGGRESSIVE_TARGETS+=(
      "homebrew downloads|rm -rf ~/Library/Caches/Homebrew/*|homebrew"
    )
  fi
}

###############################################################################
# UTILITY FUNCTIONS
###############################################################################

log_info() {
  echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
  echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
  echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
  echo -e "${RED}✗${NC} $1"
}

# Calculate directory size
get_size() {
  local path="$1"
  # Expand ~ in paths
  path="${path/\~/$HOME}"

  if [[ -e "$path" ]]; then
    if [[ -d "$path" ]]; then
      du -sh "$path" 2>/dev/null | cut -f1
    else
      ls -lh "$path" 2>/dev/null | awk '{print $5}'
    fi
  else
    echo "-"
  fi
}

# Execute cleanup command
execute_cleanup() {
  local name="$1"
  local command="$2"
  local path="$3"

  if [[ "$DRY_RUN" == true ]]; then
    log_info "[DRY RUN] Would execute: $command"
    return 0
  fi

  log_info "Cleaning: $name"
  if eval "$command" 2>/dev/null; then
    log_success "Cleaned: $name"
  else
    log_warning "Could not clean: $name (may not exist or require permissions)"
  fi
}

# Parse cleanup target string
parse_target() {
  local target="$1"
  local IFS='|'
  read -r name command category <<<"$target"
  echo "$name|$command|$category"
}

# Check if target matches category filter
matches_category_filter() {
  local category="$1"

  # If no filter set, all categories match
  if [[ ${#CATEGORY_FILTER[@]} -eq 0 ]]; then
    return 0
  fi

  # Check if category is in filter
  for filter_cat in "${CATEGORY_FILTER[@]}"; do
    if [[ "$category" == "$filter_cat" ]]; then
      return 0
    fi
  done

  return 1
}

# Multi-select for high-risk items (with fzf if available, fallback to manual selection)
multi_select() {
  local array_name="$1"
  local prompt="$2"
  local -a selected=()
  local -a temp_array
  local -a selections

  # Use eval to get the array contents
  eval "temp_array=(\"\${${array_name}[@]}\")"

  if [[ ${#temp_array[@]} -eq 0 ]]; then
    return 0
  fi

  echo ""
  echo -e "${YELLOW}High-Risk Items - Select to delete:${NC}"
  [[ -n "$prompt" ]] && echo "$prompt"
  echo ""

  # Try fzf if available
  if command -v fzf &>/dev/null; then
    use_fzf_multi_select "temp_array"
    return $?
  else
    use_manual_multi_select "temp_array"
    return $?
  fi
}

# FZF-based multi-select
use_fzf_multi_select() {
  local array_name="$1"
  local -a items

  eval "items=(\"\${${array_name}[@]}\")"

  for target in "${items[@]}"; do
    IFS='|' read -r name cmd cat <<<"$target"
    echo "$name"
  done | fzf --multi --preview="echo {}" | while read -r name; do
    for target in "${items[@]}"; do
      IFS='|' read -r tname cmd cat <<<"$target"
      if [[ "$tname" == "$name" ]]; then
        execute_cleanup "$tname" "$cmd" ""
        break
      fi
    done
  done
}

# Manual numeric selection fallback
use_manual_multi_select() {
  local array_name="$1"
  local -a items

  eval "items=(\"\${${array_name}[@]}\")"

  # Display items with indices and sizes
  local i=0
  local total_size=0
  for target in "${items[@]}"; do
    IFS='|' read -r name cmd cat <<<"$target"

    # Skip if doesn't match category filter
    if ! matches_category_filter "$cat"; then
      continue
    fi

    # Extract path from command if it's a rm -rf or similar
    local path=$(echo "$cmd" | grep -oE "~[/\w.-]*|/[/\w.-]*" | head -1)
    if [[ -n "$path" ]]; then
      local size=$(get_size "$path")
      echo -e "  [$i] $name ${BLUE}($size)${NC}"
    else
      echo -e "  [$i] $name"
    fi
    ((i++))
  done

  echo ""

  if [[ "$FORCE" == true ]] || [[ "$SKIP_INTERACTIVE" == true ]]; then
    if [[ "$FORCE" == true ]]; then
      log_warning "Force mode: auto-selecting all items"
    else
      log_info "Non-interactive mode: auto-selecting all items"
    fi
    for target in "${items[@]}"; do
      IFS='|' read -r name cmd cat <<<"$target"
      if matches_category_filter "$cat"; then
        execute_cleanup "$name" "$cmd" ""
      fi
    done
  else
    # Simple selection: accept space-separated numbers (interactive mode)
    echo "Enter numbers to select (space-separated, e.g., '0 2 3') or press Enter to skip:"
    read -r -p "> " selection_input </dev/tty

    if [[ -z "$selection_input" ]]; then
      return 0
    fi

    # Process selections by re-iterating
    local idx=0
    for target in "${items[@]}"; do
      for num in $selection_input; do
        if [[ "$idx" == "$num" ]]; then
          IFS='|' read -r name cmd cat <<<"$target"
          execute_cleanup "$name" "$cmd" ""
        fi
      done
      ((idx++))
    done
  fi
}

###############################################################################
# CLEANUP LEVELS
###############################################################################

cleanup_quick() {
  log_info "Running QUICK cleanup (daily)"
  echo ""

  for target in "${QUICK_TARGETS[@]}"; do
    IFS='|' read -r name command category <<<"$target"
    if matches_category_filter "$category"; then
      execute_cleanup "$name" "$command" ""
    fi
  done
}

cleanup_standard() {
  log_info "Running STANDARD cleanup (weekly)"
  echo ""

  cleanup_quick

  for target in "${STANDARD_TARGETS[@]}"; do
    IFS='|' read -r name command category <<<"$target"
    if matches_category_filter "$category"; then
      execute_cleanup "$name" "$command" ""
    fi
  done
}

cleanup_deep() {
  log_info "Running DEEP cleanup (monthly)"
  echo ""

  cleanup_standard

  if [[ ${#DEEP_TARGETS[@]} -gt 0 ]]; then
    echo ""
    log_warning "High-risk items - select which to delete:"
    multi_select "DEEP_TARGETS" ""
  fi
}

cleanup_aggressive() {
  log_info "Running AGGRESSIVE cleanup (yearly)"
  echo ""

  cleanup_deep

  if [[ ${#AGGRESSIVE_TARGETS[@]} -gt 0 ]]; then
    echo ""
    log_error "AGGRESSIVE mode: Mandatory confirmation for extreme operations"
    multi_select "AGGRESSIVE_TARGETS" ""
  fi
}

###############################################################################
# HELP AND USAGE
###############################################################################

show_help() {
  while IFS= read -r line; do
    echo -e "$line"
  done <<EOF
${BLUE}upperclean${NC} - Developer cleanup utility

${YELLOW}Usage:${NC}
  upperclean [LEVEL] [OPTIONS] [CATEGORIES]

${YELLOW}Cleanup Levels:${NC}
  --quick       Daily cleanup - zero risk (default: standard)
  --standard    Weekly cleanup - safe
  --deep        Monthly cleanup - medium risk
  --aggressive  Yearly cleanup - high risk

${YELLOW}Options:${NC}
  --global           Clean entire system (default: current project)
  --dry-run          Preview changes without deleting
  --force            Auto-delete without multi-select prompts
  --no-interactive   Skip interactive prompts, auto-delete all
  --help             Show this message

${YELLOW}Category Filters:${NC}
  --docker      Docker cleanup only
  --npm         npm cleanup only
  --pip         pip cleanup only
  --yarn        yarn cleanup only
  --ruby|--gem  Ruby gems cleanup
  --homebrew    Homebrew cleanup
  --apt         APT cleanup (Linux)
  --gradle      Gradle cleanup
  --cargo       Cargo cleanup
  --sbt         SBT cleanup
  --maven       Maven cleanup
  --xcode       Xcode cleanup (macOS)
  --jetbrains   JetBrains IDE cleanup
  --vscode      VS Code cleanup
  --git         Git cleanup
  --system      System cleanup

${YELLOW}Examples:${NC}
  upperclean --quick                         # Daily safe cleanup
  upperclean --standard --dry-run            # Preview standard cleanup
  upperclean --deep --docker                 # Clean Docker only (interactive)
  upperclean --standard --npm --yarn         # Clean npm and yarn (interactive)
  upperclean --quick --global --docker       # Global Docker cleanup (interactive)
  upperclean --deep --docker --no-interactive # Docker cleanup, skip prompts
  upperclean --aggressive --force --dry-run  # Preview aggressive, force mode

${YELLOW}Safety Tips:${NC}
  1. Start with --quick level
  2. Always use --dry-run first
  3. Use multi-select menus to deselect items
  4. Backup important data before --deep or --aggressive

EOF
}

###############################################################################
# MAIN
###############################################################################

main() {
  local args=("$@")

  # Show help if no arguments provided
  if [[ ${#args[@]} -eq 0 ]]; then
    show_help
    exit 0
  fi

  # Detect OS first
  detect_os

  # Parse arguments
  for arg in "${args[@]}"; do
    case "$arg" in
      --quick) CLEANUP_LEVEL="quick" ;;
      --standard) CLEANUP_LEVEL="standard" ;;
      --deep) CLEANUP_LEVEL="deep" ;;
      --aggressive) CLEANUP_LEVEL="aggressive" ;;
      --global) GLOBAL=true ;;
      --dry-run) DRY_RUN=true ;;
      --force) FORCE=true ;;
      --no-interactive|--skip-interactive) SKIP_INTERACTIVE=true ;;
      --help) show_help; exit 0 ;;
      # Category filters
      --docker) CATEGORY_FILTER+=("docker") ;;
      --npm) CATEGORY_FILTER+=("npm") ;;
      --pip) CATEGORY_FILTER+=("pip") ;;
      --yarn) CATEGORY_FILTER+=("yarn") ;;
      --ruby|--gem) CATEGORY_FILTER+=("ruby") ;;
      --homebrew|--brew) CATEGORY_FILTER+=("homebrew") ;;
      --apt) CATEGORY_FILTER+=("apt") ;;
      --gradle) CATEGORY_FILTER+=("gradle") ;;
      --cargo) CATEGORY_FILTER+=("cargo") ;;
      --sbt) CATEGORY_FILTER+=("sbt") ;;
      --maven) CATEGORY_FILTER+=("maven") ;;
      --xcode) CATEGORY_FILTER+=("xcode") ;;
      --jetbrains) CATEGORY_FILTER+=("jetbrains") ;;
      --vscode) CATEGORY_FILTER+=("vscode") ;;
      --git) CATEGORY_FILTER+=("git") ;;
      --system) CATEGORY_FILTER+=("system") ;;
      *) log_error "Unknown option: $arg"; show_help; exit 1 ;;
    esac
  done

  # Initialize targets based on OS
  setup_quick_targets
  setup_standard_targets
  setup_deep_targets
  setup_aggressive_targets

  # Show header
  echo -e "${BLUE}╔═══════════════════════════════════════╗${NC}"
  echo -e "${BLUE}║         upperclean - Cleanup          ║${NC}"
  echo -e "${BLUE}╚═══════════════════════════════════════╝${NC}"
  echo ""

  log_info "OS: $OS_TYPE"

  if [[ "$DRY_RUN" == true ]]; then
    log_warning "DRY RUN MODE - Nothing will be deleted"
  fi

  if [[ "$GLOBAL" == true ]]; then
    log_info "Scope: System-wide (global)"
  else
    log_info "Scope: Current project"
  fi

  log_info "Cleanup Level: $CLEANUP_LEVEL"

  if [[ "$FORCE" == true ]]; then
    log_warning "Force mode: Multi-select menus disabled"
  fi

  echo ""

  # Execute cleanup
  case "$CLEANUP_LEVEL" in
    quick) cleanup_quick ;;
    standard) cleanup_standard ;;
    deep) cleanup_deep ;;
    aggressive) cleanup_aggressive ;;
  esac

  echo ""
  log_success "Cleanup complete!"
}

# Run if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
